---
layout: page
order:
title: .HEX file format
heading: .HEX file format
description: What is the format of the .hex file created by the micro:bit editors?
permalink: /software/hex-format/
ref: hex-format
lang: en
assigned-to: markw
review-with: carlospa
---

## Hex files

The .hex file is in [intel-hex format](https://en.wikipedia.org/wiki/Intel_HEX). Intel hex consists of records of data, with the address in memory to store the data at the start. All data is hex-ascii encoded. All lines start with a : character. All lines end with a checksum byte that can be used to verify the integrity of the data.

A micro:bit .hex file usually starts writing data to the same fixed location in memory. Depending on the toolchain, we might expect the first line of the file to start like this:

:020000040000FA

## Universal Hex files

The latest board revision introduces a superset of the Intel-Hex format that enables compatibility across processor variants. A Universal Hex is a file that contains the binary data for both micro:bit <span class="v1">v1</span> and micro:bit <span class="v2">V2</span>, in a format that DAPLink can process and write to memory only the data relevant to its micro:bit board.

A **Universal Hex** hex file will work on a v1 or V2 board.

A clear indication that you are working with this format is that the compiled .hex file will be ~1.8Mb instead of ~700Kb in size.

The following resources will help you implement **Universal Hex** support in your application:

* [Universal Hex JavaScript Library](https://github.com/microbit-foundation/microbit-universal-hex) 
* [Detailed specification of the Universal Hex format](https://github.com/microbit-foundation/universal-hex/).

## Universal Hex Creator

We have created a [Universal Hex Creator](../universal-hex-creator) tool, to easily create a .hex file that will support all micro:bit variants.

This tool is based on the [Universal Hex JavaScript Library](https://github.com/microbit-foundation/microbit-universal-hex).

### Cross device compatibility

Including *both* .hex formats within a Universal Hex ensures the best experience for users when moving between board variants. If a v1 only .hex is detected on a V2 board it will throw an error, but a V2 only hex will fail silently on a v1. This is confusing to users and should be avoided.

There may be cases where it is not possible to support both boards, for example an accessory that targets only the V2 board variant. In these cases, to ensure the best user experience when flashing a hex file to any board variant, the file should always include an error message to signify board incompatibility to the user.

We have created a [standalone error hex](/docs/software/assets/stand-alone-error-v1.hex) that can be combined with a V2 only hex to produce a Hex that will work on a V2 board, but error if used on a v1.

[Download standalone error hex](/docs/software/assets/stand-alone-error-v1.hex){: .btn.sm-btn download}

This example shows the worst, best and acceptable (when support for v1 is impossible) cases for users. The best case is to provide a Universal Hex that supports all board variants.
![Universal Hex error 1](/docs/software/assets/hex-compatibility-errors.png)

These examples show the process of creating a Universal Hex. A v1 and V2 hex can be combined to produce a Universal Hex. If you can only support a V2 board, the standalone error can be combined with a V2 hex to produce a hex that will fail with an error on a v1 board, rather than failing silently.

|Universal Hex format                                       |V2 only Hex format                                         |
|-----------------------------------------------------------|-----------------------------------------------------------|
| ![Universal Hex error 2](/docs/software/assets/uhex2.png) | ![Universal Hex error 3](/docs/software/assets/uhex1.png) |

If you are building .hex files for both board variants, you will need to use the respective toolchains for the DAL<span class="v1">v1</span> and CODAL<span class="v2">V2</span>. See more information on the [micro:bit runtime](../runtime/).

## Micropython

See the [Micropython Hex file reference](https://microbit-micropython.readthedocs.io/en/latest/devguide/hexformat.html) for up to date information.

MicroPython builds take a "firmware.hex" image (the MicroPython pre-compiled image) and appends your script to the end of it, in a fixed 8K region at a known address. When MicroPythons starts to run on the micro:bit, it looks for a signature at this fixed location, and uses that to determine whether to run the script, or drop directly to the REPL prompt.

## Microsoft MakeCode Editor

Hex files generated by the [MakeCode Editor](https://makecode.microbit.org) include the source code of the program in addition to embedded metadata. This metadata comprises a [JSON encoded blob with information about the script](https://github.com/Microsoft/pxt/blob/437f53ca6311335c7f3f75a062ec1079b4e7806a/docs/source-embedding.md). Both the metadata and source code may be compressed and, space permitting, are stored inside the flash memory of the micro:bit. When you drag and drop a MakeCode .hex file onto the originating editor it can recover the source code, allowing the program to be modified and saved back to a .hex.
